# [Rev] CrackMe

## 📚 Overview

> *"Your manager lost his license key. You are assigned to find the license key to activate Windows software. Crack the code, forge the key, and claim the access! Flag format: ihack24{correct_license_key}"*

## ✨ Walkthrough

Given an .EXE file written in .NET so let’s decompile the file using [dotPeek](https://www.jetbrains.com/decompiler/), which is *a free .NET decompiler and assembly browser by JetBrains*. After that, head over to the Assembly Explorer and then navigate to **CrackMe (app host) > CrackMe > CrackMe > Form 1**, who knows *something interesting* can be found in that section :D.

```c#
private bool ValidateLicenseKey(string key)
{
  string str = this.SecretKey("BRQFHF@WR_+6 ,N:$78", "secret");
  return key == str;
}

private string SecretKey(string hidden, string key)
{
  StringBuilder stringBuilder = new StringBuilder();
  for (int index = 0; index < hidden.Length; ++index)
    stringBuilder.Append((char) ((uint) hidden[index] ^ (uint) key[index % key.Length]));
  return stringBuilder.ToString();
}
```

There are two functions, `ValidateLicenseKey()` to validate whether our input is equal to the license key or not and `SecretKey()` to generate the key. In short, it will **validate whether our input is equal to the generated key**. The key was generated by `XORing` each character in obfuscated value with one character from the secret key using loop (*in this case, % operator was used to iterate over the 6 characters of ‘secret’ for XOR process*). That said, let’s recreate the code using Python and run it to get the flag.

```python
hidden = "BRQFHF@WR_+6 ,N:$78"
key = "secret"

for i in range(len(hidden)):
    print(chr(ord(hidden[i]) ^ ord(key[i % len(key)])), end='')
```

## 🏳️ Flag

`ihack24{1724-2321-NBSI-HACK}`